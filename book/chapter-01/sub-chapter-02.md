## 1.2 Procedures and the Processes They Generate

After being introduced to the basic programming elements, now we need to focus on how to use those elements together. How to use them on the context of common patterns in the domain. Basically, we lack the knowledge to define which procedures are worthy and to predict the consequences of executing a procedure.

Visualizing the consequences of the actions under consideration implies that we are able to reason about it backwards. In that way, we are able to plan the process and control that process using programs. So, when we learn to visualize the process generated by various types of procedures then we are able to construct realiably programs that will behave on the desired way and we are closer to become experts.

A procedure is a pattern for the local evolution of a computation process. It defines each stage and how they are connected. We aim to make statements about the global behaviour of a process whose local evolution has been specified by a procedure. Statements such as "shape" and computational resource consumption rates. That's why we introduce some patterns in the following sections.

### 1.2.1 Linear Recursion and Iteration

Computing factorials can be implemented in different ways. First we use the substitution model to illustrate a way of achieving this by performing a sequence of computing the factorial of (n-1) and multiplying the result by n.

TODO: Insert figure 1.3

Another way to illustrate this computation is by means of using a counter to iterate until n is reached. A running product is maintained along with the counter. On each step, both of them will change according to a rule.

```
	product <= counter * product
	counter <= counter + 1
``` 

TODO: Insert figure 1.4

The interesting part here is to compare both processes. A main difference is on its "shape", they evolve differently.




### 1.2.2 Tree Recursion
### 1.2.3 Orders of Growth
